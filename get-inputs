#!/usr/bin/env python3
#
# Collect input data from various sources and hand it to the PSM dashboard.
#
# Copyright 2018 Open Tech Strategies, LLC
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This script grew gradually from 'google-sheets-api-example.py' in
# github.com/OpenTechStrategies/ots-tools/blob/master/google-sheets-client/;
# see there for Google Sheets API resources etc.

"""Get data from various sources and feed it to the PSM dashboard.

Prerequisites:

  $ sudo pip3 install -U google-api-python-client
  $ sudo pip3 install -U python-gflags 
  $ sudo pip3 install -U oauth2client
  $ sudo pip3 install -U PyGithub

  ## Edit the config file as needed.  Getting some values may be
  ## a bit of work: see https://gist.github.com/burnash/6771295 and
  ## https://developers.google.com/sheets/api/quickstart/python. 
  ## Note that you will need to have a Google account, and that
  ## account must have access to the spreadsheet whose ID you're
  ## using as your "google_sheet_id."
  $ cp psm-dashboard-config.json.tmpl psm-dashboard-config.json
  $ your-favorite-editor psm-dashboard-config.json

  ## This puts psm_reqs.py in your Python import path by putting it in
  ## the current directory.
  $ ln -s somewhere/psm/requirements/psm_reqs.py ./psm_reqs.py

Usage:

  $ ./get-inputs
"""

import httplib2
import apiclient
import oauth2client
import os
import sys
import re
import json
import psm_reqs
import github
import github.GithubException


class PSMFeature:
    """Class representing one PSM high-level feature."""
    def __init__(self, feature_id, description, subfeatures, 
                 start_date, completed_date, requirements):
        """Create a new feature named .
        FEATURE_ID (string): The identifying name for this feature.
        DESCRIPTION (string): Description of this feature.
        SUBFEATURES (list of strings): Subfeature descriptions.
        START_DATE (string): ISO-8601 date (YYYY-MM-DD HH:MM:SS) or None
        COMPLETED_DATE (string): ISO-8601 date (YYYY-MM-DD HH:MM:SS) or None
        REQUIREMENTS (list of strings): List of requirement IDs."""
        # Alas, the @dataclass decorator is new in Python 3.7,
        # so we can't really depend on it being available here.
        # www.python.org/dev/peps/pep-0557
        # hackernoon.com/a-brief-tour-of-python-3-7-data-classes-22ee5e046517
        self.feature_id = feature_id
        self.description = description
        self.subfeatures = subfeatures
        # Normally we'd use "foo_bar"-style field names for the dates,
        # but since the spec requests "camelCase", we do that instead.
        self.startDate = start_date
        self.completedDate = completed_date
        self.requirements = requirements
    def __str__(self):
        return """\
        PSM Feature:
          ID:             "%s"
          Description:    "%s"
          Subfeatures:    "%s"
          Start date:     "%s"
          Completed date: "%s"
          Requirements:   "%s"\n""" \
              % (self.feature_id.replace('"', '\\"'),
                 self.description.replace('"', '\\"'),
                 [sub.replace('"', '\\"') for sub in self.subfeatures],
                 self.startDate,
                 self.completedDate,
                 [req_id for req_id in self.requirements])


class PSMIssue:
    """Class representing one PSM non-PR GitHub issue ticket."""
    def __init__(self, owner, repos, number, title, description, 
                 status, start_date, completed_date, labels):
        """
        OWNER (string): The repository owner (GitHub user or organization).
        REPOS (string): The repository name (under OWNER at GitHub).
        NUMBER (integer): The issue number.
        TITLE (string): Issue title, a.k.a. summary.
        DESCRIPTION (string): First comment, a.k.a. body.
        STATUS (string): "Complete", "InProgress", or "NotStarted".
        START_DATE (string): An ISO-8601 date (YYYY-MM-DD HH:MM:SS)
        COMPLETED_DATE (string): An ISO-8601 date (YYYY-MM-DD HH:MM:SS)
        LABELS (list of strings): All the labels attached to this issue.
        """
        # Again, wish we had the new Python 3.7 @dataclass decorator.
        self.owner = owner
        self.repos = repos
        self.number = number
        self.url = "https://github.com/%s/%s/issues/%d" \
            % (self.owner, self.repos, self.number)
        self.title = title
        self.description = description
        self.status = status
        # Again, use "camelCase" because that's what the spec wants
        # for dates.
        # Could validate status and the two date fields here.
        # And should the dates be DateTime type, not string?
        self.startDate = start_date
        self.completedDate = completed_date
        self.labels = labels
    def __str__(self):
        return """PSM Issue:
          Number:         %d
          URL:            %s
          Title:          "%s"
          Description:    "%s"
          Status:         %s
          Start date:     %s
          Completed date: %s
          Labels:         %s\n""" \
              % (self.number,
                 self.url,
                 self.title.replace('"', '\\"'),
                 self.description.replace('"', '\\"'),
                 self.status,
                 self.start_date,
                 self.completed_date,
                 self.labels)


# Where is "class PSMRequirement", you ask?
#
# The class 'PSMRequirement' is defined in the psm_reqs.py module
# already.  We obtain instances of it from psm_reqs.get_reqs().


def to_dict(obj):
    """Return a dict representation of this object suitable for JSON."""
    d = {}
    for key, value in obj.__dict__.items():
        d[key] = value
    return d       


def main():
    # TODO: It would be nice to check access perms on the file
    # here and warn if they're too open.
    config = json.load(open('psm-dashboard-config.json'))
    
    ##### Get PSM features from the Google spreadsheet. #####
    # Grant read-only access
    google_api_scopes = 'https://www.googleapis.com/auth/spreadsheets.readonly'
    
    # TODO: Warn if this file is readable by anyone other than the user.
    google_creds_store = oauth2client.file.Storage('google-credentials.json')
    
    google_creds = google_creds_store.get()
    if not google_creds or google_creds.invalid:
        # Interactively prompt for access creds in the browser.
        flow = oauth2client.client.OAuth2WebServerFlow(
            client_id=config['google_sheet_client_id'],
            client_secret=config['google_sheet_client_secret'],
            scope=google_api_scopes,
            redirect_uri='TBD')
        google_creds = oauth2client.tools.run_flow(flow, google_creds_store)
    
    google_service = apiclient.discovery.build('sheets', 'v4', http=google_creds.authorize(httplib2.Http()))
    
    # Point Sheets API at the specified sheet.
    google_sheet_id = config['google_sheet_id']
    
    # Range must be given in "A1" notation, which is described in
    # https://developers.google.com/sheets/api/guides/concepts.
    google_sheet_range = config['google_sheet_range']
    google_sheet_result = google_service.spreadsheets().values().get(spreadsheetId=google_sheet_id,
                                                 range=google_sheet_range).execute()
    features_sheet_values = google_sheet_result.get('values', None)
    if features_sheet_values is None:
        sys.stderr.write("ERROR: Nothing found in Google Sheet '%s'." 
                         % google_sheet_id)
        sys.exit(1)

    features = {}
    this_feature = None
    reqs_list_re = re.compile("\((psm-[A-Z][A-Z]-[0-9]+\\.[0-9]+(,\\s-*)?)+\)")
    for row in features_sheet_values:
        feature_id = None
        description = None
        subfeatures = []
        start_date = None
        completed_date = None
        requirements = []
        if len(row) > 0:
            if row[0].startswith("psm-feature-"):
                feature_id = row[0]
                if feature_id in features:
                    sys.stderr.write("ERROR: Found feature '%s' twice."
                                     % feature_id)
                    sys.exit(1)
                description = row[1]
                m = reqs_list_re.search(description)
                if m is not None:
                    lst = m.group(0)
                    lst = lst.replace("(", "").replace(")", "").replace(" ", "")
                    requirements = lst.split(",")
                this_feature = PSMFeature(feature_id, description, 
                                          subfeatures,
                                          start_date, completed_date, 
                                          requirements)
                features[feature_id] = this_feature
            elif ((this_feature is not None)
                  and (len(row) == 3)
                  and (row[0] == '')
                  and (row[1] == '')):
                subfeature = row[2]
                if subfeature.startswith("- "):
                    subfeature = subfeature[2:]
                this_feature.subfeatures.append(subfeature)
            else:
                # Any other kind of non-empty row ends this feature
                this_feature = None
        else:
            # Any empty row ends this feature
            this_feature = None

    ##### Get PSM requirements from the CSV files. #####
    csv_dir = config['psm_csv_dir']
    csv_files = []
    for f in os.listdir(csv_dir):
        if f.endswith(".csv"):
            csv_files.append(os.path.join(csv_dir, f))
    reqs = psm_reqs.get_reqs(*csv_files)

    ##### Get the issue<->req mapping from GitHub. #####
    github_owner_name = config['github_owner']
    github_repos_name = config['github_repository']
    github_auth_token = config['github_auth_token_secret']
    github_api = github.Github(github_auth_token)
    # Using lazy polymorphism here: either "organization/repository"
    # or "username/repository" would work, and all the methods we
    # need exist in both types.
    try:
        github_owner = github_api.get_organization(github_owner_name)
    except github.UnknownObjectException as e:
        github_owner = github_api.get_user(github_owner_name)
    github_repos = github_owner.get_repo(github_repos_name)
    github_issues_raw = github_repos.get_issues(state="all")  # both open and closed
    issues = {}
    sys.stderr.write("DEBUG: Issues take a long time to fetch, so these\n")
    sys.stderr.write("       debugging prints will be our progress meter\n")
    sys.stderr.write("       for now.\n")
    sys.stderr.write("\n")
    for raw_issue in github_issues_raw:
        # TODO: For development, loop over only a subset of issues,
        #       because running the whole loop and waiting for the
        #       GitHub API's just-in-time fetching is too slow.
        #       Remove this check once in production, of course.
        if raw_issue.number < 700 or raw_issue.number > 740:
            continue
        if raw_issue.number in issues:
            sys.stderr.write("ERROR: Found issue %d twice." 
                             % raw_issue.number)
            sys.exit(1)
        if raw_issue.pull_request is None:
            labels = []
            for label in raw_issue.labels:
                labels.append(label.name)
            start_date = None
            completed_date = None
            if raw_issue.created_at is not None:
                start_date = str(raw_issue.created_at)[:10]
            if raw_issue.closed_at is not None:
                completed_date = str(raw_issue.closed_at)[:10]
            issue = PSMIssue(
                github_owner_name,
                github_repos_name,
                raw_issue.number,
                raw_issue.title,
                raw_issue.body,
                raw_issue.state,
                start_date,
                completed_date,
                labels)
            # Because it takes a long time to paginate through the issues,
            # we'll want some kind of progress meter.  For now, use this
            # debugging statement to know that things are moving along:
            sys.stderr.write("DEBUG: fetched issue %d\n" % issue.number)
            issues[issue.number] = issue

    ###### Link issues into requirements. #####

    # Dictionary mapping req IDs to subdictionaries; each 
    # subdictionary maps issue numbers (ints) to True.
    reqs_to_issues = {}
    for issue in issues.values():
        sys.stderr.write("DEBUG: checking issue %d'\n" % issue.number)
        for label in issue.labels:
            sys.stderr.write("DEBUG: checking label '%s'\n" % label)
            if label.startswith("Z-REQ-PSM-"):
                req_id = "psm-" + label[10:]
                sys.stderr.write("DEBUG: yes -- found req '%s'\n" % req_id)
                reqs_to_issues.setdefault(req_id, {})[issue.number] = True
    for req in reqs.values():
        # Just shoehorn it on in there.  Thanks, Python.
        setattr(req, "issues", list(reqs_to_issues.setdefault(req.req_id, {}).keys()))

    ##### Set start dates and completed dates. #####

    # For now, the start dates and completed dates are mostly
    # placeholders; eventually we'll need to calculate them (though at
    # least in PSMIssue we already have the information trivially from
    # GitHub).  Also, since PSMRequirement doesn't natively have the
    # fields at all, we add them here, albeit still as placeholders.
    for req in reqs.values():
        setattr(req, "startDate", None)
        setattr(req, "completedDate", None)

    ##### Output, finally. #####

    # TODO: The output below doesn't yet match the specification
    #       given in dashboard-data-sketch.txt, but it soon will.

    # The top-level dict that will printed as JSON.
    output = {}
    # This code could be a little D.R.Y.-er, hmm.
    output["features"] = {}
    for feature_id, feature in features.items():
        output["features"][feature_id] = to_dict(feature)
    output["requirements"] = {}
    for req_id, req in reqs.items():
        output["requirements"][req_id] = to_dict(req)
    output["issues"] = {}
    for issue_number, issue in issues.items():
        output["issues"][issue_number] = to_dict(issue)

    print("%s" % json.dumps(output, indent=4))

if __name__ == '__main__':
    main()
